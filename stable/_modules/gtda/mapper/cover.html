

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gtda.mapper.cover &mdash; giotto-tda 0.1.4 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_SVG"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> giotto-tda
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">giotto-tda</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>gtda.mapper.cover</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gtda.mapper.cover</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Covering schemes for one or several dimensions.&quot;&quot;&quot;</span>
<span class="c1"># License: GNU AGPLv3</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">,</span> <span class="n">clone</span>
<span class="kn">from</span> <span class="nn">sklearn.exceptions</span> <span class="kn">import</span> <span class="n">DataDimensionalityWarning</span><span class="p">,</span> <span class="n">NotFittedError</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">check_array</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_is_fitted</span>

<span class="kn">from</span> <span class="nn">.utils._cover</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_check_has_one_column</span><span class="p">,</span>
                           <span class="n">_remove_empty_and_duplicate_intervals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..utils._docs</span> <span class="kn">import</span> <span class="n">adapt_fit_transform_docs</span>
<span class="kn">from</span> <span class="nn">..utils.validation</span> <span class="kn">import</span> <span class="n">validate_params</span>


<div class="viewcode-block" id="OneDimensionalCover"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover">[docs]</a><span class="nd">@adapt_fit_transform_docs</span>
<span class="k">class</span> <span class="nc">OneDimensionalCover</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cover of one-dimensional data coming from open overlapping intervals.</span>

<span class="sd">    In :meth:`fit`, given a training array `X` representing a collection of</span>
<span class="sd">    real numbers, a cover of the real line by open intervals</span>
<span class="sd">    :math:`I_k = (a_k, b_k)` (:math:`k = 1, \\ldots, n`,</span>
<span class="sd">    :math:`a_k &lt; a_{k+1}`, :math:`b_k &lt; b_{k+1}`) is constructed</span>
<span class="sd">    based on the distribution of values in `X`. In :meth:`transform`,</span>
<span class="sd">    the cover is applied to a new array `X&#39;` to yield a cover of `X&#39;`.</span>

<span class="sd">    All covers constructed in :meth:`fit` have :math:`a_1 = -\\infty`</span>
<span class="sd">    and :math:`b_n = + \\infty``. Two kinds of cover are currently available:</span>
<span class="sd">    &quot;uniform&quot; and &quot;balanced&quot;. A uniform cover is such that</span>
<span class="sd">    :math:`b_1 - m = b_2 - a_2 = \\cdots = M - a_n` where :math:`m` and</span>
<span class="sd">    :math:`M` are the minimum and maximum values in `X` respectively. A</span>
<span class="sd">    balanced cover is such that approximately the same number of unique</span>
<span class="sd">    values from `X` is contained in each cover interval.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kind : ``&#39;uniform&#39;`` | ``&#39;balanced&#39;``, optional, default: ``&#39;uniform&#39;``</span>
<span class="sd">        The kind of cover to use.</span>

<span class="sd">    n_intervals : int, optional, default: ``10``</span>
<span class="sd">        The number of intervals in the cover calculated in :meth:`fit`.</span>

<span class="sd">    overlap_frac : float, optional, default: ``0.1``</span>
<span class="sd">        If the cover is uniform, this is the ratio between the length of the</span>
<span class="sd">        intersection between consecutive intervals and the length of each</span>
<span class="sd">        interval. If the cover is balanced, this is the analogous fractional</span>
<span class="sd">        overlap for a uniform cover of the closed interval</span>
<span class="sd">        :math:`(0.5, N + 0.5)` where :math:`N` is the number of unique</span>
<span class="sd">        values in the training array (see the Notes).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    left_limits_ : ndarray of shape (n_intervals,)</span>
<span class="sd">        Left limits of the cover intervals computed in :meth:`fit`. See the</span>
<span class="sd">        Notes.</span>

<span class="sd">    right_limits_ : ndarray of shape (n_intervals,)</span>
<span class="sd">        Right limits of the cover intervals computed in :meth:`fit`. See the</span>
<span class="sd">        Notes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the case of a balanced cover, :meth:`left_limits_` and</span>
<span class="sd">    :meth:`right_limits_` are computed as follows given a training array `X`:</span>
<span class="sd">    first, entries in `X` are ranked in ascending order, starting at 1 and</span>
<span class="sd">    with the same rank repeated in the case of equal values; then, the closed</span>
<span class="sd">    interval :math:`(0.5, N + 0.5)`, where :math:`N` is the maximum</span>
<span class="sd">    rank observed, is covered uniformly with parameters `n_intervals` and</span>
<span class="sd">    `overlap_frac`, yielding intervals :math:`(\\alpha_k, \\beta_k)`;</span>
<span class="sd">    the final cover is made of intervals :math:`(a_k, b_k)` where, for</span>
<span class="sd">    :math:`k &gt; 1` (resp. :math:`k &lt; ` `n_intervals`), :math:`a_k` (resp.</span>
<span class="sd">    :math:`b_k`) is the value of any entry in `X` ranked as the floor (</span>
<span class="sd">    resp. ceiling) of :math:`\\alpha_k` (resp. :math:`\\beta_k`).</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    CubicalCover</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_hyperparameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;balanced&#39;</span><span class="p">]],</span>
                        <span class="s1">&#39;n_intervals&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)],</span>
                        <span class="s1">&#39;overlap_frac&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)]}</span>

<div class="viewcode-block" id="OneDimensionalCover.__init__"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="n">n_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span> <span class="o">=</span> <span class="n">n_intervals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span> <span class="o">=</span> <span class="n">overlap_frac</span>

        <span class="k">if</span> <span class="n">overlap_frac</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`overlap_frac` must be positive,&quot;</span>
                             <span class="s2">&quot;as otherwise the intervals will not cover&quot;</span>
                             <span class="s2">&quot;the range&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap_frac</span> <span class="o">&lt;=</span> <span class="mf">1e-8</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`overlap_frac` is close to zero,&quot;</span>
                          <span class="s2">&quot;which might cause numerical issues and errors&quot;</span><span class="p">,</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_fit_uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_limits_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_limits_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_interval_limits</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">,</span> <span class="n">is_uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_fit_balanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">X_rank</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;dense&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_interval_limits</span><span class="p">(</span>
            <span class="n">X_rank</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">,</span> <span class="n">is_uniform</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">left_limits_int</span> <span class="o">=</span> <span class="n">left_limits</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">left_ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">left_limits</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left_limits_int</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">right_limits_int</span> <span class="o">=</span> <span class="n">right_limits</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">right_ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">right_limits_int</span> <span class="o">==</span> <span class="n">right_limits</span><span class="p">,</span>
                               <span class="n">right_limits_int</span><span class="p">,</span>
                               <span class="n">right_limits_int</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_limits_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_limits_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_from_ranks</span><span class="p">(</span>
            <span class="n">X_rank</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">left_ranks</span><span class="p">,</span> <span class="n">right_ranks</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="OneDimensionalCover.fit"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute all cover interval limits according to `X` and store them</span>
<span class="sd">        in :attr:`left_limits_` and :attr:`right_limits_`. Then, return the</span>
<span class="sd">        estimator.</span>

<span class="sd">        This method is here to implement the usual scikit-learn API and hence</span>
<span class="sd">        work in pipelines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples,) or (n_samples, 1)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyperparameters</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_check_has_one_column</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">is_uniform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span>
        <span class="n">fitter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_uniform</span> <span class="k">if</span> <span class="n">is_uniform</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_balanced</span>
        <span class="k">return</span> <span class="n">fitter</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">X</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_limits_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_limits_</span><span class="p">)</span>

<div class="viewcode-block" id="OneDimensionalCover.transform"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a cover of `X` according to the cover of the real line</span>
<span class="sd">        computed in :meth:`fit`, and return it as a two-dimensional boolean</span>
<span class="sd">        array. Each column indicates the location of entries in `X`</span>
<span class="sd">        belonging to a common cover interval.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples,) or (n_samples, 1)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xt : ndarray of shape (n_samples, n_cover_sets)</span>
<span class="sd">            Encoding of the cover of `X` as a boolean array. In general,</span>
<span class="sd">            ``n_cover_sets`` is less than or equal to `n_intervals` as empty</span>
<span class="sd">            or duplicated cover sets are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_check_has_one_column</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;balanced&#39;</span><span class="p">:</span>
            <span class="c1"># Test whether self.left_limits_ and self.right_limits_ have</span>
            <span class="c1"># been created -- to catch cases in which transform is run after</span>
            <span class="c1"># fit_transform but not after fit.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_limit_attrs</span><span class="p">()</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">_remove_empty_and_duplicate_intervals</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>

    <span class="k">def</span> <span class="nf">_fit_transform_balanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shortcut in the case of a balanced cover, avoiding overhead</span>
<span class="sd">        from calculation of self.left_limits_ and self.right_limits_.</span>

<span class="sd">        Stores hidden attributes _left_limits and _right_limits which refer</span>
<span class="sd">        to a cover of the interval (-0.5, n_unique - 0.5) where n_unique is</span>
<span class="sd">        the number of unique points in X.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_rank</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;dense&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_left_limits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_interval_limits</span><span class="p">(</span>
            <span class="n">X_rank</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">,</span> <span class="n">is_uniform</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">X_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">X_rank</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span>
                                 <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">))</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_rank</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_limits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">X_rank</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_limits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span>

    <span class="k">def</span> <span class="nf">_fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_uniform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_transform_balanced</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span>

<div class="viewcode-block" id="OneDimensionalCover.fit_transform"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit to the data, then transform it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples,) or (n_samples, 1)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xt : ndarray of shape (n_samples, n_cover_sets)</span>
<span class="sd">            Encoding of the cover of `X` as a boolean array. In general,</span>
<span class="sd">            ``n_cover_sets`` is less than or equal to `n_intervals` as empty</span>
<span class="sd">            or duplicated cover sets are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyperparameters</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_check_has_one_column</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">_remove_empty_and_duplicate_intervals</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>

<div class="viewcode-block" id="OneDimensionalCover.get_fitted_intervals"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.get_fitted_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">get_fitted_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the open intervals computed in :meth:`fit`, as a list of</span>
<span class="sd">        tuples (a, b) where a &lt; b.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;balanced&#39;</span><span class="p">:</span>
            <span class="c1"># Test whether self.left_limits_ and self.right_limits_ have</span>
            <span class="c1"># been created</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_limit_attrs</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_limits_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_limits_</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_check_limit_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">limit_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;left_limits_&#39;</span><span class="p">,</span> <span class="s1">&#39;right_limits_&#39;</span><span class="p">]</span>
        <span class="n">has_limits</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">limit_attrs</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotFittedError</span><span class="p">(</span>
                <span class="s2">&quot;When the cover is balanced and n_intervals &gt; 1, the left &quot;</span>
                <span class="s2">&quot;and right limits of the cover intervals are not &quot;</span>
                <span class="s2">&quot;explicitly calculated during &#39;fit_transform&#39;. Please &quot;</span>
                <span class="s2">&quot;call &#39;fit&#39; explicitly on the same data before using this &quot;</span>
                <span class="s2">&quot;method.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_interval_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">n_intervals</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="p">,</span>
                              <span class="n">is_uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_uniform</span><span class="p">:</span>
            <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">only_one_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_val</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume X is the result of a call to scipy.stats.rankdata</span>
            <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">only_one_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_val</span> <span class="o">==</span> <span class="n">max_val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Allow X to have one unique sample only if one interval is required,</span>
        <span class="c1"># in which case the fitted interval will be (-np.inf, np.inf).</span>
        <span class="k">if</span> <span class="n">only_one_pt</span> <span class="ow">and</span> <span class="n">n_intervals</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only one unique filter value found, cannot fit </span><span class="si">{}</span><span class="s2"> &gt; 1 &quot;</span>
                <span class="s2">&quot;intervals.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">))</span>

        <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_cover_limits</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">n_intervals</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_uniform</span><span class="p">:</span>
            <span class="n">left_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span>

    <span class="k">def</span> <span class="nf">_limits_from_ranks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_rank</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">left_ranks</span><span class="p">,</span> <span class="n">right_ranks</span><span class="p">):</span>
        <span class="n">n_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span>
        <span class="n">X_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">X_rank</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span>
                                 <span class="p">(</span><span class="n">X_rank</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_intervals</span><span class="p">))</span>
        <span class="n">left_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_rank</span> <span class="o">==</span> <span class="n">left_ranks</span><span class="p">)</span>
        <span class="n">right_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_rank</span> <span class="o">==</span> <span class="n">right_ranks</span><span class="p">)</span>
        <span class="n">left_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">left_mask</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">))</span>
        <span class="n">right_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">right_mask</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">))</span>
        <span class="n">left_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">X</span><span class="p">[</span><span class="n">nonzero_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">nonzero_indices</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">nonzero_indices</span> <span class="ow">in</span> <span class="n">left_indices</span>
        <span class="p">])</span>
        <span class="n">right_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">X</span><span class="p">[</span><span class="n">nonzero_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">nonzero_indices</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">nonzero_indices</span> <span class="ow">in</span> <span class="n">right_indices</span>
        <span class="p">])</span>
        <span class="n">left_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">right_limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cover_limits</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">n_intervals</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="p">):</span>
        <span class="c1"># Construct a uniform cover of the interval [min_val, max_val].</span>
        <span class="c1"># Let the length of each interval be l. The equation to solve for l is</span>
        <span class="c1"># (n_intervals - 1) * l * (1 - overlap_frac) + l = max_val - min_val.</span>
        <span class="c1"># The maximum left endpoint is at min_val + (n_intervals - 1) * (1 -</span>
        <span class="c1"># overlap_frac) * l</span>
        <span class="n">total_len</span> <span class="o">=</span> <span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span>
        <span class="n">interval_len</span> <span class="o">=</span> <span class="n">total_len</span> <span class="o">/</span> \
            <span class="p">(</span><span class="n">n_intervals</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_intervals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">overlap_frac</span><span class="p">)</span>

        <span class="n">last</span> <span class="o">=</span> <span class="n">min_val</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_intervals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">overlap_frac</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_len</span>
        <span class="n">left_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_intervals</span><span class="p">,</span>
                                  <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">right_limits</span> <span class="o">=</span> <span class="n">left_limits</span> <span class="o">+</span> <span class="n">interval_len</span>
        <span class="k">return</span> <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span></div>


<div class="viewcode-block" id="CubicalCover"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover">[docs]</a><span class="nd">@adapt_fit_transform_docs</span>
<span class="k">class</span> <span class="nc">CubicalCover</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cover of multi-dimensional data coming from overlapping hypercubes</span>
<span class="sd">    (technically, parallelopipeds) given by taking products of one-dimensional</span>
<span class="sd">    intervals.</span>

<span class="sd">    In :meth:`fit`, :class:`OneDimensionalCover` objects are fitted</span>
<span class="sd">    independently on each column of the input array, according to the same</span>
<span class="sd">    parameters passed to the constructor. For example, if the</span>
<span class="sd">    :class:`CubicalCover` object is instantiated with ``kind=&#39;uniform&#39;``,</span>
<span class="sd">    ``n_intervals=10`` and ``overlap_frac=0.1``, then each column of the</span>
<span class="sd">    input array is used to construct a cover of the real line by 10</span>
<span class="sd">    equal-length intervals with fractional overlap of 0.1. Each element of the</span>
<span class="sd">    resulting multi-dimensional cover of Euclidean space is of the form</span>
<span class="sd">    :math:`I_{i, \\ldots, k} = I^{(0)}_i \\times \\cdots \\times</span>
<span class="sd">    I^{(d-1)}_k` where :math:`d` is the number of columns in the input</span>
<span class="sd">    array, and :math:`I^{(l)}_j` is the :math:`j`th cover interval</span>
<span class="sd">    constructed for feature dimension :math:`l`. In :meth:`transform`,</span>
<span class="sd">    the cover is applied to a new array `X&#39;` to yield a cover of `X&#39;`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kind : ``&#39;uniform&#39;`` | ``&#39;balanced&#39;``, optional, default: ``&#39;uniform&#39;``</span>
<span class="sd">        The kind of cover to use.</span>

<span class="sd">    n_intervals : int, optional, default: ``10``</span>
<span class="sd">        The number of intervals in the covers of each feature dimension</span>
<span class="sd">        calculated in :meth:`fit`.</span>

<span class="sd">    overlap_frac : float, optional, default: ``0.1``</span>
<span class="sd">        The fractional overlap between consecutive intervals in the covers of</span>
<span class="sd">        each feature dimension calculated in :meth:`fit`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    OneDimensionalCover</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_hyperparameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;balanced&#39;</span><span class="p">]],</span>
                        <span class="s1">&#39;n_intervals&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)],</span>
                        <span class="s1">&#39;overlap_frac&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]}</span>

<div class="viewcode-block" id="CubicalCover.__init__"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="n">n_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span> <span class="o">=</span> <span class="n">n_intervals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span> <span class="o">=</span> <span class="n">overlap_frac</span></div>

    <span class="k">def</span> <span class="nf">_clone_and_apply_to_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">coverer</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="c1"># method is either a fit-type or a fit_transform-type method</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">clone</span><span class="p">(</span><span class="n">coverer</span><span class="p">),</span> <span class="n">method_name</span><span class="p">)(</span><span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ve</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Only one unique filter value found, cannot &quot;</span> \
                             <span class="s2">&quot;fit </span><span class="si">{}</span><span class="s2"> &gt; 1 intervals.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Only one unique filter value found along feature &quot;</span>
                    <span class="s2">&quot;dimension </span><span class="si">{}</span><span class="s2">, cannot fit </span><span class="si">{}</span><span class="s2"> &gt; 1 intervals there.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ve</span>

    <span class="k">def</span> <span class="nf">_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">coverer</span> <span class="o">=</span> <span class="n">OneDimensionalCover</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
                                      <span class="n">n_intervals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span>
                                      <span class="n">overlap_frac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">)</span>
        <span class="n">is_uniform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span>
        <span class="n">fitter</span> <span class="o">=</span> <span class="s1">&#39;_fit_uniform&#39;</span> <span class="k">if</span> <span class="n">is_uniform</span> <span class="k">else</span> <span class="s1">&#39;_fit_balanced&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coverers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clone_and_apply_to_column</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">coverer</span><span class="p">,</span> <span class="n">fitter</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_features_fit</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="CubicalCover.fit"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute all open cover parallelopipeds according to `X`,</span>
<span class="sd">        as products of one-dimensional intervals covering each feature</span>
<span class="sd">        dimension separately. Then, return the estimator.</span>

<span class="sd">        This method is here to implement the usual scikit-learn API and hence</span>
<span class="sd">        work in pipelines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyperparameters</span><span class="p">)</span>
        <span class="c1"># reshape filter function values derived from FunctionTransformer</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="c1"># Calculate 1D cover for each column</span>
        <span class="n">covers</span> <span class="o">=</span> <span class="p">[</span><span class="n">coverer</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coverer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coverers</span><span class="p">)]</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_one_dim_covers</span><span class="p">(</span><span class="n">covers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span>

<div class="viewcode-block" id="CubicalCover.transform"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a cover of `X` according to the cover of Euclidean space</span>
<span class="sd">        computed in :meth:`fit`, and return it as a two-dimensional boolean</span>
<span class="sd">        array whose each column indicates the location of entries in `X`</span>
<span class="sd">        belonging to a common cover interval.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xt : ndarray of shape (n_samples, n_cover_sets)</span>
<span class="sd">            Encoding of the cover of `X` as a boolean array. In general,</span>
<span class="sd">            ``n_cover_sets`` is less than or equal to n_intervals *</span>
<span class="sd">            n_features` as empty or duplicated cover sets are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_coverers&#39;</span><span class="p">)</span>
        <span class="c1"># Reshape filter function values derived from FunctionTransformer</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">n_features_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features_fit</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_features</span> <span class="o">!=</span> <span class="n">n_features_fit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionalityWarning</span><span class="p">(</span>
                <span class="s2">&quot;Different number of columns between &#39;fit&#39; (</span><span class="si">{}</span><span class="s2">) and &quot;</span>
                <span class="s2">&quot;&#39;transform&#39; (</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_features_fit</span><span class="p">,</span> <span class="n">n_features</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;balanced&#39;</span><span class="p">:</span>
            <span class="c1"># Test on the first coverer whether the left_limits_ and</span>
            <span class="c1"># right_limits_ attributes are present</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coverers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_check_limit_attrs</span><span class="p">()</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>

<div class="viewcode-block" id="CubicalCover.fit_transform"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit to the data, then transform it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xt : ndarray of shape (n_samples, n_cover_sets)</span>
<span class="sd">            Encoding of the cover of `X` as a boolean array. In general,</span>
<span class="sd">            ``n_cover_sets`` is less than or equal to `n_intervals *</span>
<span class="sd">            n_features` as empty or duplicated cover sets are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyperparameters</span><span class="p">)</span>
        <span class="c1"># reshape filter function values derived from FunctionTransformer</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Xt</span>

        <span class="c1"># Calculate 1D cover for each column</span>
        <span class="n">coverer</span> <span class="o">=</span> <span class="n">OneDimensionalCover</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
                                      <span class="n">n_intervals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span>
                                      <span class="n">overlap_frac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">)</span>
        <span class="n">coverers</span> <span class="o">=</span> <span class="p">[</span><span class="n">clone</span><span class="p">(</span><span class="n">coverer</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">fit_transformer</span> <span class="o">=</span> <span class="s1">&#39;_fit_transform_balanced&#39;</span>
        <span class="n">covers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clone_and_apply_to_column</span><span class="p">,</span>
                    <span class="n">X</span><span class="p">,</span> <span class="n">coverer</span><span class="p">,</span> <span class="n">fit_transformer</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coverer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coverers</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># Only store attributes if above succeeds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coverers</span> <span class="o">=</span> <span class="n">coverers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_features_fit</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_one_dim_covers</span><span class="p">(</span><span class="n">covers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_one_dim_covers</span><span class="p">(</span><span class="n">covers</span><span class="p">):</span>
        <span class="c1"># Stack intervals for each cover</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">cover</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cover</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">cover</span> <span class="ow">in</span> <span class="n">covers</span>
        <span class="p">)</span>

        <span class="c1"># Calculate masks for pullback cover</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">intervals</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="n">_remove_empty_and_duplicate_intervals</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, L2F

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>