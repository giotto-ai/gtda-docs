

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Getting Started with Mapper &mdash; giotto-tda 0.1.4 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_SVG"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> giotto-tda
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Getting Started with Mapper</a><ul>
<li><a class="reference internal" href="#useful-references">Useful references</a><ul>
<li><a class="reference internal" href="#license-agplv3">License: AGPLv3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#import-libraries">Import libraries</a></li>
<li><a class="reference internal" href="#generate-and-visualise-data">Generate and visualise data</a></li>
<li><a class="reference internal" href="#configure-the-mapper-pipeline">Configure the Mapper pipeline</a></li>
<li><a class="reference internal" href="#visualise-the-mapper-graph">Visualise the Mapper graph</a></li>
<li><a class="reference internal" href="#run-the-mapper-pipeline">Run the Mapper pipeline</a></li>
<li><a class="reference internal" href="#creating-custom-filter-functions">Creating custom filter functions</a></li>
<li><a class="reference internal" href="#visualise-the-2d-mapper-graph-interactively">Visualise the 2D Mapper graph interactively</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">giotto-tda</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Getting Started with Mapper</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gallery/mapper_quickstart.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-gallery-mapper-quickstart-py"><span class="std std-ref">here</span></a> to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="getting-started-with-mapper">
<span id="sphx-glr-gallery-mapper-quickstart-py"></span><h1>Getting Started with Mapper<a class="headerlink" href="#getting-started-with-mapper" title="Permalink to this headline">¶</a></h1>
<p>In this notebook we explore a few of the core features included in
giotto-tda’s implementation of the <a class="reference external" href="https://research.math.osu.edu/tgda/mapperPBG.pdf">Mapper
algorithm</a>.</p>
<div class="section" id="useful-references">
<h2>Useful references<a class="headerlink" href="#useful-references" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1710.04019">An introduction to Topological Data Analysis: fundamental and
practical aspects for data
scientists</a></p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/1904.11044">An Introduction to Topological Data Analysis for Physicists: From
LGM to FRBs</a></p></li>
</ul>
<div class="section" id="license-agplv3">
<h3>License: AGPLv3<a class="headerlink" href="#license-agplv3" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="import-libraries">
<h2>Import libraries<a class="headerlink" href="#import-libraries" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Data wrangling</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>  <span class="c1"># Not a requirement of giotto-tda, but is compatible with the gtda.mapper module</span>

<span class="c1"># Data viz</span>
<span class="kn">from</span> <span class="nn">plotting</span> <span class="kn">import</span> <span class="n">plot_point_cloud</span>

<span class="c1"># TDA magic</span>
<span class="kn">from</span> <span class="nn">gtda.mapper</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CubicalCover</span><span class="p">,</span>
    <span class="n">make_mapper_pipeline</span><span class="p">,</span>
    <span class="n">Projection</span><span class="p">,</span>
    <span class="n">plot_static_mapper_graph</span><span class="p">,</span>
    <span class="n">plot_interactive_mapper_graph</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">gtda.mapper.utils.visualization</span> <span class="kn">import</span> <span class="n">set_node_sizeref</span>

<span class="c1"># ML tools</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="generate-and-visualise-data">
<h2>Generate and visualise data<a class="headerlink" href="#generate-and-visualise-data" title="Permalink to this headline">¶</a></h2>
<p>As a simple example, let’s generate a two-dimensional point cloud of two
concentric circles. The goal will be to examine how Mapper can be used
to generate a topological graph that captures the salient features of
the data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">make_circles</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="n">plot_point_cloud</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="configure-the-mapper-pipeline">
<h2>Configure the Mapper pipeline<a class="headerlink" href="#configure-the-mapper-pipeline" title="Permalink to this headline">¶</a></h2>
<p>Given a dataset <span class="math notranslate nohighlight">\({\cal D}\)</span> of points <span class="math notranslate nohighlight">\(x \in \mathbb{R}^n\)</span>,
the basic steps behind Mapper are as follows:</p>
<ol class="arabic simple">
<li><p>Map <span class="math notranslate nohighlight">\({\cal D}\)</span> to a lower-dimensional space using a <strong>filter
function</strong> $ f: <a href="#id1"><span class="problematic" id="id2">:raw-latex:`\mathbb{R}`^n
:raw-latex:`</span></a>to <cite>:raw-latex:</cite>mathbb{R}`^m $. Common choices for the
filter function include projection onto one or more axes via PCA or
density-based methods. In giotto-tda, you can import a variety of
filter functions as follows:</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gtda.mapper.filter</span> <span class="kn">import</span> <span class="n">FilterFunctionName</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Construct a cover of the filter values
<span class="math notranslate nohighlight">\({\cal U} = (U_i)_{i\in I}\)</span>, typically in the form of a set of
overlapping intervals which have constant length. As with the filter,
a choice of cover can be imported as follows:</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gtda.mapper.cover</span> <span class="kn">import</span> <span class="n">CoverName</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>For each interval <span class="math notranslate nohighlight">\(U_i \in {\cal U}\)</span> cluster the points in the
preimage <span class="math notranslate nohighlight">\(f^{-1}(U_i)\)</span> into sets
<span class="math notranslate nohighlight">\(C_{i,1}, \ldots , C_{i,k_i}\)</span>. The choice of clustering
algorithm can be any of scikit-learn’s <a class="reference external" href="https://scikit-learn.org/stable/modules/clustering.html">clustering
methods</a>
or an implementation of agglomerative clustering in giotto-tda:</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># scikit-learn method</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">ClusteringAlgorithm</span>
<span class="c1"># giotto-tda method</span>
<span class="kn">from</span> <span class="nn">gtda.mapper.cluster</span> <span class="kn">import</span> <span class="n">FirstSimpleGap</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>Construct the topological graph whose vertices are the cluster sets
<span class="math notranslate nohighlight">\((C_{i,j})_{i\in I, j \in \{1,\ldots,k_i\}}\)</span> and an edge exists
between two nodes if they share points in common:
<span class="math notranslate nohighlight">\(C_{i,j} \cap C_{k,l} \neq \emptyset\)</span>. This step is handled
automatically by giotto-tda.</p></li>
</ol>
<p>These four steps are implemented in the <code class="docutils literal notranslate"><span class="pre">MapperPipeline</span></code> object that
mimics the <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> class from scikit-learn. We provide a
convenience function <code class="docutils literal notranslate"><span class="pre">make_mapper_pipeline()</span></code> that allows you to pass
the choice of filter function, cover, and clustering algorithm as
arguments. For example, to project our data onto the <span class="math notranslate nohighlight">\(x\)</span>- and
<span class="math notranslate nohighlight">\(y\)</span>-axes, we could setup the pipeline as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define filter function - can be any scikit-learn transformer</span>
<span class="n">filter_func</span> <span class="o">=</span> <span class="n">Projection</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="c1"># Define cover</span>
<span class="n">cover</span> <span class="o">=</span> <span class="n">CubicalCover</span><span class="p">(</span><span class="n">n_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="c1"># Choose clustering algorithm - default is DBSCAN</span>
<span class="n">clusterer</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">()</span>

<span class="c1"># Configure parallelism of clustering step</span>
<span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Initialise pipeline</span>
<span class="n">pipe</span> <span class="o">=</span> <span class="n">make_mapper_pipeline</span><span class="p">(</span>
    <span class="n">filter_func</span><span class="o">=</span><span class="n">filter_func</span><span class="p">,</span>
    <span class="n">cover</span><span class="o">=</span><span class="n">cover</span><span class="p">,</span>
    <span class="n">clusterer</span><span class="o">=</span><span class="n">clusterer</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="visualise-the-mapper-graph">
<h2>Visualise the Mapper graph<a class="headerlink" href="#visualise-the-mapper-graph" title="Permalink to this headline">¶</a></h2>
<p>With the Mapper pipeline at hand, it is now a simple matter to visualise
it. To warm up, let’s examine the graph in two-dimensions using the
default arguments of giotto-tda’s plotting function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plot_static_mapper_graph</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="c1"># Display figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;scrollZoom&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>From the figure we can see that we have captured the salient topological
features of our underlying data, namely two holes!</p>
<p>By default, the nodes of the Mapper graph are colored by the mean value
of the points that belong to a given node. However, in this example it
is more instructive to colour by the <span class="math notranslate nohighlight">\(x\)</span>- and <span class="math notranslate nohighlight">\(y\)</span>-axes. This
can be achieved by toggling the <code class="docutils literal notranslate"><span class="pre">color_by_columns_dropdown</span></code>, which
calculates the coloring for each column in the input data array. At the
same time, let’s configure the choice of colorscale:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plotly_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;node_trace_marker_colorscale&quot;</span><span class="p">:</span> <span class="s2">&quot;Blues&quot;</span><span class="p">}</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plot_static_mapper_graph</span><span class="p">(</span>
    <span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color_by_columns_dropdown</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plotly_kwargs</span><span class="o">=</span><span class="n">plotly_kwargs</span>
<span class="p">)</span>
<span class="c1"># Display figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;scrollZoom&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>In the dropdown menu, the entry <code class="docutils literal notranslate"><span class="pre">color_variable</span></code> refers to a
user-defined quantity to color by - by default it is the average value
of the points in each node. In general, one can configure this quantity
to be an array, a scikit-learn transformer, or a list of indices to
select from the data. For example, coloring by a PCA component can be
implemented as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialise estimator to color graph by</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plot_static_mapper_graph</span><span class="p">(</span>
    <span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color_by_columns_dropdown</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color_variable</span><span class="o">=</span><span class="n">pca</span>
<span class="p">)</span>
<span class="c1"># Display figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;scrollZoom&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>It is also possible to feed <code class="docutils literal notranslate"><span class="pre">plot_static_mapper_graph()</span></code> a pandas
DataFrame:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
<span class="n">data_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Before plotting we need to update the Mapper pipeline to know about the
projection onto the column names. This can be achieved using the
<code class="docutils literal notranslate"><span class="pre">set_params()</span></code> method as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipe</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">filter_func</span><span class="o">=</span><span class="n">Projection</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]))</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plot_static_mapper_graph</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">data_df</span><span class="p">,</span> <span class="n">color_by_columns_dropdown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Display figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;scrollZoom&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>By default, <code class="docutils literal notranslate"><span class="pre">plot_static_mapper_graph()</span></code> uses the Kamada–Kawai
algorithm for the layout; however any of the layout algorithms defined
in python-igraph are supported (see
<a class="reference external" href="https://igraph.org/python/doc/igraph.Graph-class.html">here</a> for a
list of possible layouts). For example, we can switch to the
Fruchterman–Reingold layout as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reset back to numpy projection</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">filter_func</span><span class="o">=</span><span class="n">Projection</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plot_static_mapper_graph</span><span class="p">(</span>
    <span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="s2">&quot;fruchterman_reingold&quot;</span><span class="p">,</span> <span class="n">color_by_columns_dropdown</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="c1"># Display figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;scrollZoom&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>It is also possible to visualise the Mapper graph in 3-dimensions by
configuring the <code class="docutils literal notranslate"><span class="pre">layout_dim</span></code> argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plot_static_mapper_graph</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">layout_dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">color_by_columns_dropdown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Display figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;scrollZoom&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="section" id="run-the-mapper-pipeline">
<h2>Run the Mapper pipeline<a class="headerlink" href="#run-the-mapper-pipeline" title="Permalink to this headline">¶</a></h2>
<p>Behind the scenes of <code class="docutils literal notranslate"><span class="pre">plot_static_mapper_graph()</span></code> is a
<code class="docutils literal notranslate"><span class="pre">MapperPipeline</span></code> object <code class="docutils literal notranslate"><span class="pre">pipe</span></code> that can be used like a typical
scikit-learn estimator. For example, to extract the underlying graph
data structure we can do the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">graph</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting graph is an <a class="reference external" href="https://igraph.org/python/">python-igraph</a>
object that contains metadata that is stored in the form of
dictionaries. We can access this data as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_metadata&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">node_id</span></code> is a globally unique node identifier used to construct
the graph, while <code class="docutils literal notranslate"><span class="pre">pullback_set_label</span></code> and <code class="docutils literal notranslate"><span class="pre">partial_cluster_label</span></code>
refer to the interval and cluster sets described above. The
<code class="docutils literal notranslate"><span class="pre">node_elements</span></code> refers to the indices of our original data that belong
to each node. For example, to find which points belong to the first node
of the graph we can access the desired data as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">node_id</span><span class="p">,</span> <span class="n">node_elements</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_metadata&quot;</span><span class="p">][</span><span class="s2">&quot;node_id&quot;</span><span class="p">],</span>
    <span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_metadata&quot;</span><span class="p">][</span><span class="s2">&quot;node_elements&quot;</span><span class="p">],</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="s2">&quot;Node Id: </span><span class="si">{}</span><span class="s2">, </span><span class="se">\n</span><span class="s2">Node elements: </span><span class="si">{}</span><span class="s2">, </span><span class="se">\n</span><span class="s2">Data points: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">node_id</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">node_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">node_elements</span></code> are handy for situations when we want to customise
e.g. the size of the node scale. In this example, we use the utility
function <code class="docutils literal notranslate"><span class="pre">set_node_sizeref()</span></code> and pass the function as a plotly
argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Configure scale for node sizes</span>
<span class="n">plotly_kwargs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;node_trace_marker_sizeref&quot;</span><span class="p">:</span> <span class="n">set_node_sizeref</span><span class="p">(</span><span class="n">node_elements</span><span class="p">,</span> <span class="n">node_scale</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plot_static_mapper_graph</span><span class="p">(</span>
    <span class="n">pipe</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">layout_dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">color_by_columns_dropdown</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">plotly_kwargs</span><span class="o">=</span><span class="n">plotly_kwargs</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Display figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;scrollZoom&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>The resulting graph is much easier to decipher with the enlarged node
scaling!</p>
</div>
<div class="section" id="creating-custom-filter-functions">
<h2>Creating custom filter functions<a class="headerlink" href="#creating-custom-filter-functions" title="Permalink to this headline">¶</a></h2>
<p>In some cases, the list of filter functions provided in <code class="docutils literal notranslate"><span class="pre">filter.py</span></code> or
scikit-learn may not be sufficient for the task at hand. In such cases,
one can pass any callable to the pipeline that acts <em>row-wise</em> on the
input data. For example, we can project by taking the sum of the
<span class="math notranslate nohighlight">\((x,y)\)</span> coordinates as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">filter_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span>

<span class="n">pipe</span> <span class="o">=</span> <span class="n">make_mapper_pipeline</span><span class="p">(</span>
    <span class="n">filter_func</span><span class="o">=</span><span class="n">filter_func</span><span class="p">,</span>
    <span class="n">cover</span><span class="o">=</span><span class="n">cover</span><span class="p">,</span>
    <span class="n">clusterer</span><span class="o">=</span><span class="n">clusterer</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plot_static_mapper_graph</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">plotly_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="c1"># Display figure</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;scrollZoom&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>In general, any callable (i.e. function) that operates <strong>row-wise</strong> can
be passed.</p>
</div>
<div class="section" id="visualise-the-2d-mapper-graph-interactively">
<h2>Visualise the 2D Mapper graph interactively<a class="headerlink" href="#visualise-the-2d-mapper-graph-interactively" title="Permalink to this headline">¶</a></h2>
<p>In general, buidling useful Mapper graphs requires some iteration
through the various parameters in the cover and clustering algorithm. To
simplify that process, giotto-tda provides an interactive figure that
can be configured in real-time. If invalid parameters are selected, the
<em>Show logs</em> checkbox can be used to see what went wrong.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipe</span> <span class="o">=</span> <span class="n">make_mapper_pipeline</span><span class="p">()</span>

<span class="c1"># Generate interactive plot</span>
<span class="n">plot_interactive_mapper_graph</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color_by_columns_dropdown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.000 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-gallery-mapper-quickstart-py">
<div class="sphx-glr-download docutils container">
<p><a class="reference download internal" download="" href="../_downloads/1d38b902ca11e13851bac6f5275c30df/mapper_quickstart.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">mapper_quickstart.py</span></code></a></p>
</div>
<div class="sphx-glr-download docutils container">
<p><a class="reference download internal" download="" href="../_downloads/00e655e4a325fc84b25c44a97e9b4896/mapper_quickstart.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">mapper_quickstart.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, L2F

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>