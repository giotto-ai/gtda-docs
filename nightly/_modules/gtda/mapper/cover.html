


<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gtda.mapper.cover &mdash; giotto-tda 0.1.4 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_SVG"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link href="../../../_static/style.css" rel="stylesheet" type="text/css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<script>require=requirejs;</script>

</head>

<body class="wy-body-for-nav">

  
  <a href="{/choose_version.html">Checkout other versions!</a>

  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/tda_logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../library.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../library.html#guiding-principles">Guiding principles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../library.html#s-guide-to-giotto-tda">30s guide to Giotto-TDA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../library.html#resources">Resources</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../library.html#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../library.html#use-cases">Use cases</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../library.html#what-s-new">Whatâ€™s new</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../library.html#library-name-change">Library name change</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../library.html#change-of-license">Change of license</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../library.html#major-features-and-improvements">Major Features and Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../library.html#bug-fixes">Bug Fixes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../library.html#backwards-incompatible-changes">Backwards-Incompatible Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../library.html#thanks-to-our-contributors">Thanks to our Contributors</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#user-installation">User installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#developer-installation">Developer installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../installation.html#linux">Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../installation.html#macos">macOS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../installation.html#windows">Windows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../installation.html#id2">Boost</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../installation.html#pre-built-binaries">Pre-built binaries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../installation.html#source-code">Source code</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../installation.html#already-installed-boost-version">Already installed boost version</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../installation.html#troubleshooting">Troubleshooting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../installation.html#id3">Source code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../installation.html#to-install">To install:</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../installation.html#testing">Testing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">API reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/mapper.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code>: Mapper</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/mapper.html#filters">Filters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/filters/gtda.mapper.Projection.html">Projection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/filters/gtda.mapper.Eccentricity.html">Eccentricity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/filters/gtda.mapper.Entropy.html">Entropy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/mapper.html#covers">Covers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html">OneDimensionalCover</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html">CubicalCover</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/mapper.html#clustering">Clustering</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/clustering/gtda.mapper.FirstSimpleGap.html">FirstSimpleGap</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/clustering/gtda.mapper.FirstHistogramGap.html">FirstHistogramGap</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/mapper.html#pipeline">Pipeline</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/pipeline/gtda.mapper.pipeline.make_mapper_pipeline.html">make_mapper_pipeline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/pipeline/gtda.mapper.pipeline.MapperPipeline.html">MapperPipeline</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/mapper.html#visualization">Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/visualization/gtda.mapper.visualization.plot_static_mapper_graph.html">plot_static_mapper_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/mapper/visualization/gtda.mapper.visualization.plot_interactive_mapper_graph.html">plot_interactive_mapper_graph</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/mapper.html#utilities">Utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/gtda.mapper.utils.decorators.method_to_transform.html">method_to_transform</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/gtda.mapper.utils.pipeline.transformer_from_callable_on_rows.html">transformer_from_callable_on_rows</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/homology.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.homology</span></code>: Persistent homology</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/homology/gtda.homology.VietorisRipsPersistence.html">VietorisRipsPersistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/homology/gtda.homology.SparseRipsPersistence.html">SparseRipsPersistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/homology/gtda.homology.EuclideanCechPersistence.html">EuclideanCechPersistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/homology/gtda.homology.CubicalPersistence.html">CubicalPersistence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/diagrams.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>: Persistence diagrams</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/diagrams.html#preprocessing">Preprocessing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/preprocessing/gtda.diagrams.ForgetDimension.html">ForgetDimension</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/preprocessing/gtda.diagrams.Scaler.html">Scaler</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/preprocessing/gtda.diagrams.Filtering.html">Filtering</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/diagrams.html#distances">Distances</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/distances/gtda.diagrams.PairwiseDistance.html">PairwiseDistance</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/diagrams.html#representations">Representations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/representations/gtda.diagrams.PersistenceLandscape.html">PersistenceLandscape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/representations/gtda.diagrams.BettiCurve.html">BettiCurve</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/representations/gtda.diagrams.HeatKernel.html">HeatKernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/representations/gtda.diagrams.PersistenceImage.html">PersistenceImage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/representations/gtda.diagrams.Silhouette.html">Silhouette</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/diagrams.html#features">Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/features/gtda.diagrams.Amplitude.html">Amplitude</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/diagrams/features/gtda.diagrams.PersistenceEntropy.html">PersistenceEntropy</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/point_clouds.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.point_clouds</span></code>: Point clouds</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/gtda.point_clouds.ConsistentRescaling.html">ConsistentRescaling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/gtda.point_clouds.ConsecutiveRescaling.html">ConsecutiveRescaling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/time_series.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.time_series</span></code>: Time series</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/time_series.html#preprocessing">Preprocessing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/time_series/preprocessing/gtda.time_series.SlidingWindow.html">SlidingWindow</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/time_series/preprocessing/gtda.time_series.Resampler.html">Resampler</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/time_series/preprocessing/gtda.time_series.Stationarizer.html">Stationarizer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/time_series.html#time-delay-embedding">Time-delay embedding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/time_series/embedding/gtda.time_series.TakensEmbedding.html">TakensEmbedding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/time_series.html#target-preparation">Target preparation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/time_series/target_preparation/gtda.time_series.Labeller.html">Labeller</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/time_series.html#dynamical-systems">Dynamical systems</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/time_series/dynamical_system/gtda.time_series.PermutationEntropy.html">PermutationEntropy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/time_series.html#multivariate">Multivariate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/time_series/multivariate/gtda.time_series.PearsonDissimilarity.html">PearsonDissimilarity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/graphs.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.graphs</span></code>: Graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/graphs.html#graph-creation">Graph creation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/graphs/creation/gtda.graphs.TransitionGraph.html">TransitionGraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/graphs/creation/gtda.graphs.KNeighborsGraph.html">KNeighborsGraph</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/graphs.html#graph-processing">Graph processing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/graphs/processing/gtda.graphs.GraphGeodesicDistance.html">GraphGeodesicDistance</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/base.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.base</span></code>: Base</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/base/gtda.base.TransformerResamplerMixin.html">TransformerResamplerMixin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/base/gtda.base.PlotterMixin.html">PlotterMixin</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/pipeline.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.pipeline</span></code>: Pipeline</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/base/gtda.pipeline.Pipeline.html">Pipeline</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/gtda.pipeline.make_pipeline.html">make_pipeline</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/meta_transformers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.meta_transformers</span></code>: Convenience pipelines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/base/gtda.meta_transformers.EntropyGenerator.html">EntropyGenerator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/base/gtda.meta_transformers.BettiCurveGenerator.html">BettiCurveGenerator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/base/gtda.meta_transformers.LandscapeGenerator.html">LandscapeGenerator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/validation.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.utils</span></code>: Validation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/utils/gtda.utils.check_diagram.html">check_diagram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/utils/gtda.utils.validate_params.html">validate_params</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/images.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.images</span></code>: Images</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/images.html#preprocessing">Preprocessing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/images/gtda.images.Binarizer.html">Binarizer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/images/gtda.images.Inverter.html">Inverter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/images/gtda.images.Padder.html">Padder</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/images/gtda.images.ImageToPointCloud.html">ImageToPointCloud</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/images.html#filtrations">Filtrations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/images/gtda.images.HeightFiltration.html">HeightFiltration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/images/gtda.images.RadialFiltration.html">RadialFiltration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/images/gtda.images.DilationFiltration.html">DilationFiltration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/images/gtda.images.ErosionFiltration.html">ErosionFiltration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../modules/generated/images/gtda.images.SignedDistanceFiltration.html">SignedDistanceFiltration</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/index.html">Examples, tutorials and plotting utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/basic.html">Basic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/basic.html#topological-feature-extraction-using-vietorisrips-and-persistenceentropy">Topological feature extraction using VietorisRips and PersistenceEntropy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/basic.html#getting-started-with-mapper">Getting Started with Mapper</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../notebooks/basic.html#useful-references">Useful references</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/advanced.html">Advanced</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/advanced.html#case-study-lorenz-attractor">Case study: Lorenz attractor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/advanced.html#case-study-classification-of-shapes">Case study: Classification of shapes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../notebooks/advanced.html#can-two-dimensional-topological-voids-exist-in-two-dimensions">Can two-dimensional topological voids exist in two dimensions?</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../theory/glossary.html">Theory Glossary</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../theory/glossary.html#symbols">Symbols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../theory/glossary.html#homology">Homology</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#cubical-complex">Cubical complex</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../theory/glossary.html#reference">Reference:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#simplicial-complex">Simplicial complex</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#abstract-simplicial-complex">Abstract simplicial complex</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#ordered-simplicial-complex">Ordered simplicial complex</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#directed-simplicial-complex">Directed simplicial complex</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#clique-or-flag-complexes">Clique or flag complexes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#chain-complex">Chain complex</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#homology-and-cohomology">Homology and cohomology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#simplicial-chains-and-simplicial-homology">Simplicial chains and simplicial homology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#cubical-chains-and-cubical-homology">Cubical chains and cubical homology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#filtered-complex">Filtered complex</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#cellwise-filtration">Cellwise filtration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#persistence-module">Persistence module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#persistent-simplicial-co-homology">Persistent simplicial (co)homology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#vietoris-rips-complex-and-vietoris-rips-persistence">Vietoris-Rips complex and Vietoris-Rips persistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#cech-complex-and-cech-persistence">ÄŒech complex and ÄŒech persistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#multiset">Multiset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#persistence-diagram">Persistence diagram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#wasserstein-and-bottleneck-distance">Wasserstein and bottleneck distance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../theory/glossary.html#reference-1">Reference:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#persistence-landscape">Persistence landscape</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../theory/glossary.html#reference-2">Reference:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#persistence-landscape-norm">Persistence landscape norm</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../theory/glossary.html#references">References:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#weighted-silhouette">Weighted silhouette</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../theory/glossary.html#references-1">References:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#amplitude">Amplitude</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#persistence-entropy">Persistence entropy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../theory/glossary.html#references-2">References:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#betti-curve">Betti curve</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#metric-space">Metric space</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#euclidean-distance-and-norm">Euclidean distance and norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#finite-metric-spaces-and-point-clouds">Finite metric spaces and point clouds</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../theory/glossary.html#time-series">Time series</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#id29">Time series</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#takens-embedding">Takens embedding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../theory/glossary.html#reference-3">Reference:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#manifold">Manifold</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../theory/glossary.html#references-3">References:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../theory/glossary.html#compact-subset">Compact subset</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../theory/glossary.html#bibliography">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/index.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing/index.html#guidelines">Guidelines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#essentials-for-contributing">Essentials for contributing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../contributing/index.html#contributor-license-agreement">Contributor License Agreement</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../contributing/index.html#pull-requests">Pull requests</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../contributing/index.html#issues">Issues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#contribution-guidelines-and-standards">Contribution guidelines and standards</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../contributing/index.html#general-guidelines-and-philosophy-for-contribution">General guidelines and philosophy for contribution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../contributing/index.html#c-coding-style">C++ coding style</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../contributing/index.html#python-coding-style">Python coding style</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../contributing/index.html#git-pre-commit-hook">Git pre-commit hook</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../contributing/index.html#running-unit-tests">Running unit tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../release.html#release-0-1-4">Release 0.1.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#library-name-change">Library name change</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#change-of-license">Change of license</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#major-features-and-improvements">Major Features and Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#bug-fixes">Bug Fixes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#backwards-incompatible-changes">Backwards-Incompatible Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#thanks-to-our-contributors">Thanks to our Contributors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../release.html#release-0-1-3">Release 0.1.3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id1">Major Features and Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id2">Bug Fixes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id3">Backwards-Incompatible Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id4">Thanks to our Contributors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../release.html#release-0-1-2">Release 0.1.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id5">Major Features and Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id6">Bug Fixes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id7">Backwards-Incompatible Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id8">Thanks to our Contributors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../release.html#release-0-1-1">Release 0.1.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id9">Major Features and Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id10">Bug Fixes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id11">Backwards-Incompatible Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id12">Thanks to our Contributors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../release.html#release-0-1-0">Release 0.1.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id13">Major Features and Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id14">Bug Fixes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id15">Backwards-Incompatible Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id16">Thanks to our Contributors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../release.html#release-0-1a-0">Release 0.1a.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../faq.html#i-am-a-researcher-can-i-use-giotto-tda-in-my-project">I am a researcher. Can I use giotto-tda in my project?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../faq.html#i-cannot-install-giotto-tda">I cannot install <code class="docutils literal notranslate"><span class="pre">giotto-tda</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../faq.html#there-are-many-tda-libraries-available-how-is-giotto-tda-different">There are many TDA libraries available. How is <code class="docutils literal notranslate"><span class="pre">giotto-tda</span></code> different?</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">giotto-tda</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>gtda.mapper.cover</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gtda.mapper.cover</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Covering schemes for one or several dimensions.&quot;&quot;&quot;</span>
<span class="c1"># License: GNU AGPLv3</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">,</span> <span class="n">clone</span>
<span class="kn">from</span> <span class="nn">sklearn.exceptions</span> <span class="kn">import</span> <span class="n">DataDimensionalityWarning</span><span class="p">,</span> <span class="n">NotFittedError</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">check_array</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_is_fitted</span>

<span class="kn">from</span> <span class="nn">.utils._cover</span> <span class="kn">import</span> <span class="n">_check_has_one_column</span><span class="p">,</span> \
    <span class="n">_remove_empty_and_duplicate_intervals</span>
<span class="kn">from</span> <span class="nn">..utils._docs</span> <span class="kn">import</span> <span class="n">adapt_fit_transform_docs</span>
<span class="kn">from</span> <span class="nn">..utils.intervals</span> <span class="kn">import</span> <span class="n">Interval</span>
<span class="kn">from</span> <span class="nn">..utils.validation</span> <span class="kn">import</span> <span class="n">validate_params</span>


<div class="viewcode-block" id="OneDimensionalCover"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover">[docs]</a><span class="nd">@adapt_fit_transform_docs</span>
<span class="k">class</span> <span class="nc">OneDimensionalCover</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cover of one-dimensional data coming from open overlapping intervals.</span>

<span class="sd">    In :meth:`fit`, given a training array `X` representing a collection of</span>
<span class="sd">    real numbers, a cover of the real line by open intervals</span>
<span class="sd">    :math:`I_k = (a_k, b_k)` (:math:`k = 1, \\ldots, n`,</span>
<span class="sd">    :math:`a_k &lt; a_{k+1}`, :math:`b_k &lt; b_{k+1}`) is constructed</span>
<span class="sd">    based on the distribution of values in `X`. In :meth:`transform`,</span>
<span class="sd">    the cover is applied to a new array `X&#39;` to yield a cover of `X&#39;`.</span>

<span class="sd">    All covers constructed in :meth:`fit` have :math:`a_1 = -\\infty`</span>
<span class="sd">    and :math:`b_n = + \\infty``. Two kinds of cover are currently available:</span>
<span class="sd">    &quot;uniform&quot; and &quot;balanced&quot;. A uniform cover is such that</span>
<span class="sd">    :math:`b_1 - m = b_2 - a_2 = \\cdots = M - a_n` where :math:`m` and</span>
<span class="sd">    :math:`M` are the minimum and maximum values in `X` respectively. A</span>
<span class="sd">    balanced cover is such that approximately the same number of unique</span>
<span class="sd">    values from `X` is contained in each cover interval.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kind : ``&#39;uniform&#39;`` | ``&#39;balanced&#39;``, optional, default: ``&#39;uniform&#39;``</span>
<span class="sd">        The kind of cover to use.</span>

<span class="sd">    n_intervals : int, optional, default: ``10``</span>
<span class="sd">        The number of intervals in the cover calculated in :meth:`fit`.</span>

<span class="sd">    overlap_frac : float, optional, default: ``0.1``</span>
<span class="sd">        If the cover is uniform, this is the ratio between the length of the</span>
<span class="sd">        intersection between consecutive intervals and the length of each</span>
<span class="sd">        interval. If the cover is balanced, this is the analogous fractional</span>
<span class="sd">        overlap for a uniform cover of the closed interval</span>
<span class="sd">        :math:`(0.5, N + 0.5)` where :math:`N` is the number of unique</span>
<span class="sd">        values in the training array (see the Notes).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    left_limits_ : ndarray of shape (n_intervals,)</span>
<span class="sd">        Left limits of the cover intervals computed in :meth:`fit`. See the</span>
<span class="sd">        Notes.</span>

<span class="sd">    right_limits_ : ndarray of shape (n_intervals,)</span>
<span class="sd">        Right limits of the cover intervals computed in :meth:`fit`. See the</span>
<span class="sd">        Notes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the case of a balanced cover, :meth:`left_limits_` and</span>
<span class="sd">    :meth:`right_limits_` are computed as follows given a training array `X`:</span>
<span class="sd">    first, entries in `X` are ranked in ascending order, starting at 1 and</span>
<span class="sd">    with the same rank repeated in the case of equal values; then, the closed</span>
<span class="sd">    interval :math:`(0.5, N + 0.5)`, where :math:`N` is the maximum</span>
<span class="sd">    rank observed, is covered uniformly with parameters `n_intervals` and</span>
<span class="sd">    `overlap_frac`, yielding intervals :math:`(\\alpha_k, \\beta_k)`;</span>
<span class="sd">    the final cover is made of intervals :math:`(a_k, b_k)` where, for</span>
<span class="sd">    :math:`k &gt; 1` (resp. :math:`k &lt; ` `n_intervals`), :math:`a_k` (resp.</span>
<span class="sd">    :math:`b_k`) is the value of any entry in `X` ranked as the floor (</span>
<span class="sd">    resp. ceiling) of :math:`\\alpha_k` (resp. :math:`\\beta_k`).</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    CubicalCover</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_hyperparameters</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;balanced&#39;</span><span class="p">]},</span>
        <span class="s1">&#39;n_intervals&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)},</span>
        <span class="s1">&#39;overlap_frac&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s1">&#39;neither&#39;</span><span class="p">)}</span>
    <span class="p">}</span>

<div class="viewcode-block" id="OneDimensionalCover.__init__"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="n">n_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span> <span class="o">=</span> <span class="n">n_intervals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span> <span class="o">=</span> <span class="n">overlap_frac</span>

        <span class="k">if</span> <span class="n">overlap_frac</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`overlap_frac` must be positive,&quot;</span>
                             <span class="s2">&quot;as otherwise the intervals will not cover&quot;</span>
                             <span class="s2">&quot;the range&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap_frac</span> <span class="o">&lt;=</span> <span class="mf">1e-8</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`overlap_frac` is close to zero,&quot;</span>
                          <span class="s2">&quot;which might cause numerical issues and errors&quot;</span><span class="p">,</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_fit_uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_limits_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_limits_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_interval_limits</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">,</span> <span class="n">is_uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_fit_balanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">X_rank</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;dense&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_interval_limits</span><span class="p">(</span>
            <span class="n">X_rank</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">,</span> <span class="n">is_uniform</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">left_limits_int</span> <span class="o">=</span> <span class="n">left_limits</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">left_ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">left_limits</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left_limits_int</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">right_limits_int</span> <span class="o">=</span> <span class="n">right_limits</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">right_ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">right_limits_int</span> <span class="o">==</span> <span class="n">right_limits</span><span class="p">,</span>
                               <span class="n">right_limits_int</span><span class="p">,</span>
                               <span class="n">right_limits_int</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_limits_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_limits_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_from_ranks</span><span class="p">(</span>
            <span class="n">X_rank</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">left_ranks</span><span class="p">,</span> <span class="n">right_ranks</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="OneDimensionalCover.fit"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute all cover interval limits according to `X` and store them</span>
<span class="sd">        in :attr:`left_limits_` and :attr:`right_limits_`. Then, return the</span>
<span class="sd">        estimator.</span>

<span class="sd">        This method is here to implement the usual scikit-learn API and hence</span>
<span class="sd">        work in pipelines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples,) or (n_samples, 1)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">validate_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyperparameters</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_check_has_one_column</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">is_uniform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span>
        <span class="n">fitter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_uniform</span> <span class="k">if</span> <span class="n">is_uniform</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_balanced</span>
        <span class="k">return</span> <span class="n">fitter</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">X</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_limits_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_limits_</span><span class="p">)</span>

<div class="viewcode-block" id="OneDimensionalCover.transform"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a cover of `X` according to the cover of the real line</span>
<span class="sd">        computed in :meth:`fit`, and return it as a two-dimensional boolean</span>
<span class="sd">        array. Each column indicates the location of entries in `X`</span>
<span class="sd">        belonging to a common cover interval.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples,) or (n_samples, 1)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xt : ndarray of shape (n_samples, n_cover_sets)</span>
<span class="sd">            Encoding of the cover of `X` as a boolean array. In general,</span>
<span class="sd">            ``n_cover_sets`` is less than or equal to `n_intervals` as empty</span>
<span class="sd">            or duplicated cover sets are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_check_has_one_column</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;balanced&#39;</span><span class="p">:</span>
            <span class="c1"># Test whether self.left_limits_ and self.right_limits_ have</span>
            <span class="c1"># been created -- to catch cases in which transform is run after</span>
            <span class="c1"># fit_transform but not after fit.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_limit_attrs</span><span class="p">()</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">_remove_empty_and_duplicate_intervals</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>

    <span class="k">def</span> <span class="nf">_fit_transform_balanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shortcut in the case of a balanced cover, avoiding overhead</span>
<span class="sd">        from calculation of self.left_limits_ and self.right_limits_.</span>

<span class="sd">        Stores hidden attributes _left_limits and _right_limits which refer</span>
<span class="sd">        to a cover of the interval (-0.5, n_unique - 0.5) where n_unique is</span>
<span class="sd">        the number of unique points in X.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_rank</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;dense&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_left_limits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_interval_limits</span><span class="p">(</span>
            <span class="n">X_rank</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">,</span> <span class="n">is_uniform</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">X_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">X_rank</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span>
                                 <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">))</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_rank</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_limits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">X_rank</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_limits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span>

    <span class="k">def</span> <span class="nf">_fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_uniform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_transform_balanced</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span>

<div class="viewcode-block" id="OneDimensionalCover.fit_transform"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit to the data, then transform it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples,) or (n_samples, 1)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xt : ndarray of shape (n_samples, n_cover_sets)</span>
<span class="sd">            Encoding of the cover of `X` as a boolean array. In general,</span>
<span class="sd">            ``n_cover_sets`` is less than or equal to `n_intervals` as empty</span>
<span class="sd">            or duplicated cover sets are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyperparameters</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_check_has_one_column</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">_remove_empty_and_duplicate_intervals</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>

<div class="viewcode-block" id="OneDimensionalCover.get_fitted_intervals"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.OneDimensionalCover.html#gtda.mapper.OneDimensionalCover.get_fitted_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">get_fitted_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the open intervals computed in :meth:`fit`, as a list of</span>
<span class="sd">        tuples (a, b) where a &lt; b.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;balanced&#39;</span><span class="p">:</span>
            <span class="c1"># Test whether self.left_limits_ and self.right_limits_ have</span>
            <span class="c1"># been created</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_limit_attrs</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_limits_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_limits_</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_check_limit_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">limit_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;left_limits_&#39;</span><span class="p">,</span> <span class="s1">&#39;right_limits_&#39;</span><span class="p">]</span>
        <span class="n">has_limits</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">limit_attrs</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotFittedError</span><span class="p">(</span>
                <span class="s2">&quot;When the cover is balanced and n_intervals &gt; 1, the left &quot;</span>
                <span class="s2">&quot;and right limits of the cover intervals are not &quot;</span>
                <span class="s2">&quot;explicitly calculated during &#39;fit_transform&#39;. Please &quot;</span>
                <span class="s2">&quot;call &#39;fit&#39; explicitly on the same data before using this &quot;</span>
                <span class="s2">&quot;method.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_interval_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">n_intervals</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="p">,</span>
                              <span class="n">is_uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_uniform</span><span class="p">:</span>
            <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">only_one_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_val</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume X is the result of a call to scipy.stats.rankdata</span>
            <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">only_one_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_val</span> <span class="o">==</span> <span class="n">max_val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Allow X to have one unique sample only if one interval is required,</span>
        <span class="c1"># in which case the fitted interval will be (-np.inf, np.inf).</span>
        <span class="k">if</span> <span class="n">only_one_pt</span> <span class="ow">and</span> <span class="n">n_intervals</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Only one unique filter value found, cannot fit &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{n_intervals}</span><span class="s2"> &gt; 1 intervals.&quot;</span><span class="p">)</span>

        <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_cover_limits</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">n_intervals</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_uniform</span><span class="p">:</span>
            <span class="n">left_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span>

    <span class="k">def</span> <span class="nf">_limits_from_ranks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_rank</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">left_ranks</span><span class="p">,</span> <span class="n">right_ranks</span><span class="p">):</span>
        <span class="n">n_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span>
        <span class="n">X_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">X_rank</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span>
                                 <span class="p">(</span><span class="n">X_rank</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_intervals</span><span class="p">))</span>
        <span class="n">left_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_rank</span> <span class="o">==</span> <span class="n">left_ranks</span><span class="p">)</span>
        <span class="n">right_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_rank</span> <span class="o">==</span> <span class="n">right_ranks</span><span class="p">)</span>
        <span class="n">left_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">left_mask</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">))</span>
        <span class="n">right_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">right_mask</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">))</span>
        <span class="n">left_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">X</span><span class="p">[</span><span class="n">nonzero_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">nonzero_indices</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">nonzero_indices</span> <span class="ow">in</span> <span class="n">left_indices</span>
        <span class="p">])</span>
        <span class="n">right_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">X</span><span class="p">[</span><span class="n">nonzero_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">nonzero_indices</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">nonzero_indices</span> <span class="ow">in</span> <span class="n">right_indices</span>
        <span class="p">])</span>
        <span class="n">left_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">right_limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cover_limits</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">n_intervals</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="p">):</span>
        <span class="c1"># Construct a uniform cover of the interval [min_val, max_val].</span>
        <span class="c1"># Let the length of each interval be l. The equation to solve for l is</span>
        <span class="c1"># (n_intervals - 1) * l * (1 - overlap_frac) + l = max_val - min_val.</span>
        <span class="c1"># The maximum left endpoint is at min_val + (n_intervals - 1) * (1 -</span>
        <span class="c1"># overlap_frac) * l</span>
        <span class="n">total_len</span> <span class="o">=</span> <span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span>
        <span class="n">interval_len</span> <span class="o">=</span> <span class="n">total_len</span> <span class="o">/</span> \
            <span class="p">(</span><span class="n">n_intervals</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_intervals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">overlap_frac</span><span class="p">)</span>

        <span class="n">last</span> <span class="o">=</span> <span class="n">min_val</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_intervals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">overlap_frac</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_len</span>
        <span class="n">left_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_intervals</span><span class="p">,</span>
                                  <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">right_limits</span> <span class="o">=</span> <span class="n">left_limits</span> <span class="o">+</span> <span class="n">interval_len</span>
        <span class="k">return</span> <span class="n">left_limits</span><span class="p">,</span> <span class="n">right_limits</span></div>


<div class="viewcode-block" id="CubicalCover"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover">[docs]</a><span class="nd">@adapt_fit_transform_docs</span>
<span class="k">class</span> <span class="nc">CubicalCover</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cover of multi-dimensional data coming from overlapping hypercubes</span>
<span class="sd">    (technically, parallelopipeds) given by taking products of one-dimensional</span>
<span class="sd">    intervals.</span>

<span class="sd">    In :meth:`fit`, :class:`OneDimensionalCover` objects are fitted</span>
<span class="sd">    independently on each column of the input array, according to the same</span>
<span class="sd">    parameters passed to the constructor. For example, if the</span>
<span class="sd">    :class:`CubicalCover` object is instantiated with ``kind=&#39;uniform&#39;``,</span>
<span class="sd">    ``n_intervals=10`` and ``overlap_frac=0.1``, then each column of the</span>
<span class="sd">    input array is used to construct a cover of the real line by 10</span>
<span class="sd">    equal-length intervals with fractional overlap of 0.1. Each element of the</span>
<span class="sd">    resulting multi-dimensional cover of Euclidean space is of the form</span>
<span class="sd">    :math:`I_{i, \\ldots, k} = I^{(0)}_i \\times \\cdots \\times</span>
<span class="sd">    I^{(d-1)}_k` where :math:`d` is the number of columns in the input</span>
<span class="sd">    array, and :math:`I^{(l)}_j` is the :math:`j`th cover interval</span>
<span class="sd">    constructed for feature dimension :math:`l`. In :meth:`transform`,</span>
<span class="sd">    the cover is applied to a new array `X&#39;` to yield a cover of `X&#39;`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kind : ``&#39;uniform&#39;`` | ``&#39;balanced&#39;``, optional, default: ``&#39;uniform&#39;``</span>
<span class="sd">        The kind of cover to use.</span>

<span class="sd">    n_intervals : int, optional, default: ``10``</span>
<span class="sd">        The number of intervals in the covers of each feature dimension</span>
<span class="sd">        calculated in :meth:`fit`.</span>

<span class="sd">    overlap_frac : float, optional, default: ``0.1``</span>
<span class="sd">        The fractional overlap between consecutive intervals in the covers of</span>
<span class="sd">        each feature dimension calculated in :meth:`fit`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    OneDimensionalCover</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_hyperparameters</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;balanced&#39;</span><span class="p">]},</span>
        <span class="s1">&#39;n_intervals&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)},</span>
        <span class="s1">&#39;overlap_frac&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s1">&#39;neither&#39;</span><span class="p">)}</span>
    <span class="p">}</span>

<div class="viewcode-block" id="CubicalCover.__init__"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="n">n_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">overlap_frac</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span> <span class="o">=</span> <span class="n">n_intervals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span> <span class="o">=</span> <span class="n">overlap_frac</span></div>

    <span class="k">def</span> <span class="nf">_clone_and_apply_to_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">coverer</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="c1"># method is either a fit-type or a fit_transform-type method</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">clone</span><span class="p">(</span><span class="n">coverer</span><span class="p">),</span> <span class="n">method_name</span><span class="p">)(</span><span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ve</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sa">f</span><span class="s2">&quot;Only one unique filter value found, cannot &quot;</span> \
                             <span class="sa">f</span><span class="s2">&quot;fit </span><span class="si">{self.n_intervals}</span><span class="s2"> &gt; 1 intervals.&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Only one unique filter value found along feature &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{i}</span><span class="s2">, cannot fit </span><span class="si">{self.n_intervals}</span><span class="s2"> &gt; 1 &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;intervals there.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ve</span>

    <span class="k">def</span> <span class="nf">_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">coverer</span> <span class="o">=</span> <span class="n">OneDimensionalCover</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
                                      <span class="n">n_intervals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span>
                                      <span class="n">overlap_frac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">)</span>
        <span class="n">is_uniform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span>
        <span class="n">fitter</span> <span class="o">=</span> <span class="s1">&#39;_fit_uniform&#39;</span> <span class="k">if</span> <span class="n">is_uniform</span> <span class="k">else</span> <span class="s1">&#39;_fit_balanced&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coverers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clone_and_apply_to_column</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">coverer</span><span class="p">,</span> <span class="n">fitter</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_features_fit</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="CubicalCover.fit"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute all open cover parallelopipeds according to `X`,</span>
<span class="sd">        as products of one-dimensional intervals covering each feature</span>
<span class="sd">        dimension separately. Then, return the estimator.</span>

<span class="sd">        This method is here to implement the usual scikit-learn API and hence</span>
<span class="sd">        work in pipelines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">validate_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyperparameters</span><span class="p">)</span>

        <span class="c1"># reshape filter function values derived from FunctionTransformer</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="c1"># Calculate 1D cover for each column</span>
        <span class="n">covers</span> <span class="o">=</span> <span class="p">[</span><span class="n">coverer</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coverer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coverers</span><span class="p">)]</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_one_dim_covers</span><span class="p">(</span><span class="n">covers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span>

<div class="viewcode-block" id="CubicalCover.transform"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a cover of `X` according to the cover of Euclidean space</span>
<span class="sd">        computed in :meth:`fit`, and return it as a two-dimensional boolean</span>
<span class="sd">        array whose each column indicates the location of entries in `X`</span>
<span class="sd">        belonging to a common cover interval.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xt : ndarray of shape (n_samples, n_cover_sets)</span>
<span class="sd">            Encoding of the cover of `X` as a boolean array. In general,</span>
<span class="sd">            ``n_cover_sets`` is less than or equal to n_intervals *</span>
<span class="sd">            n_features` as empty or duplicated cover sets are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_coverers&#39;</span><span class="p">)</span>
        <span class="c1"># Reshape filter function values derived from FunctionTransformer</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Xt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Xt</span> <span class="o">=</span> <span class="n">Xt</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">n_features_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features_fit</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="n">Xt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_features</span> <span class="o">!=</span> <span class="n">n_features_fit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionalityWarning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Different number of columns between `fit` (</span><span class="si">{n_features_fit}</span><span class="s2">)&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; and `transform` (</span><span class="si">{n_features}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;balanced&#39;</span><span class="p">:</span>
            <span class="c1"># Test on the first coverer whether the left_limits_ and</span>
            <span class="c1"># right_limits_ attributes are present</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coverers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_check_limit_attrs</span><span class="p">()</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>

<div class="viewcode-block" id="CubicalCover.fit_transform"><a class="viewcode-back" href="../../../modules/generated/mapper/covers/gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit to the data, then transform it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray of shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>

<span class="sd">        y : None</span>
<span class="sd">            There is no need for a target in a transformer, yet the pipeline</span>
<span class="sd">            API requires this parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xt : ndarray of shape (n_samples, n_cover_sets)</span>
<span class="sd">            Encoding of the cover of `X` as a boolean array. In general,</span>
<span class="sd">            ``n_cover_sets`` is less than or equal to `n_intervals *</span>
<span class="sd">            n_features` as empty or duplicated cover sets are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyperparameters</span><span class="p">)</span>
        <span class="c1"># reshape filter function values derived from FunctionTransformer</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Xt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Xt</span> <span class="o">=</span> <span class="n">Xt</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Xt</span>

        <span class="c1"># Calculate 1D cover for each column</span>
        <span class="n">coverer</span> <span class="o">=</span> <span class="n">OneDimensionalCover</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
                                      <span class="n">n_intervals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_intervals</span><span class="p">,</span>
                                      <span class="n">overlap_frac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_frac</span><span class="p">)</span>
        <span class="n">coverers</span> <span class="o">=</span> <span class="p">[</span><span class="n">clone</span><span class="p">(</span><span class="n">coverer</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Xt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">fit_transformer</span> <span class="o">=</span> <span class="s1">&#39;_fit_transform_balanced&#39;</span>
        <span class="n">covers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clone_and_apply_to_column</span><span class="p">,</span>
                    <span class="n">Xt</span><span class="p">,</span> <span class="n">coverer</span><span class="p">,</span> <span class="n">fit_transformer</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coverer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coverers</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># Only store attributes if above succeeds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coverers</span> <span class="o">=</span> <span class="n">coverers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_features_fit</span> <span class="o">=</span> <span class="n">Xt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_one_dim_covers</span><span class="p">(</span><span class="n">covers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_one_dim_covers</span><span class="p">(</span><span class="n">covers</span><span class="p">):</span>
        <span class="c1"># Stack intervals for each cover</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">cover</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cover</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">cover</span> <span class="ow">in</span> <span class="n">covers</span>
        <span class="p">)</span>

        <span class="c1"># Calculate masks for pullback cover</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">intervals</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">Xt</span> <span class="o">=</span> <span class="n">_remove_empty_and_duplicate_intervals</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xt</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, L2F

    </p>
  </div>
    
    
      Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Versions</span>
    current: nightly
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <!--start_versions_tag-->
      <!--path_to_root:../../../-->
      
      <dd><a href="../../../../nightly/index.html">nightly</a></dd>
      
      <dd><a href="../../../../stable/index.html">stable</a></dd>
      
      <!--end_versions_tag-->
    </dl>
  </div>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>