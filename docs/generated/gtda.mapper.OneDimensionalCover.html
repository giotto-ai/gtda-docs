

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gtda.mapper.OneDimensionalCover &mdash; giotto-tda 0.1.4 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_SVG"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="gtda.mapper.CubicalCover" href="gtda.mapper.CubicalCover.html" />
    <link rel="prev" title="gtda.mapper.Entropy" href="gtda.mapper.Entropy.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> giotto-tda
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.Projection.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code>.Projection</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.Eccentricity.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code>.Eccentricity</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.Entropy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code>.Entropy</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code>.OneDimensionalCover</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.CubicalCover.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code>.CubicalCover</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.FirstSimpleGap.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code>.FirstSimpleGap</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.FirstHistogramGap.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code>.FirstHistogramGap</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.pipeline.make_mapper_pipeline.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper.pipeline</span></code>.make_mapper_pipeline</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.pipeline.MapperPipeline.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper.pipeline</span></code>.MapperPipeline</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.visualization.plot_static_mapper_graph.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper.visualization</span></code>.plot_static_mapper_graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.visualization.plot_interactive_mapper_graph.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper.visualization</span></code>.plot_interactive_mapper_graph</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.utils.decorators.method_to_transform.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper.utils.decorators</span></code>.method_to_transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.mapper.utils.pipeline.transformer_from_callable_on_rows.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper.utils.pipeline</span></code>.transformer_from_callable_on_rows</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.homology.VietorisRipsPersistence.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.homology</span></code>.VietorisRipsPersistence</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.homology.ConsistentRescaling.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.homology</span></code>.ConsistentRescaling</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.diagrams.ForgetDimension.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>.ForgetDimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.diagrams.Scaler.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>.Scaler</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.diagrams.Filtering.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>.Filtering</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.diagrams.PairwiseDistance.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>.PairwiseDistance</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.diagrams.Amplitude.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>.Amplitude</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.diagrams.PersistenceEntropy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>.PersistenceEntropy</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.diagrams.PersistenceLandscape.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>.PersistenceLandscape</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.diagrams.BettiCurve.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>.BettiCurve</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.diagrams.HeatKernel.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.diagrams</span></code>.HeatKernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.time_series.SlidingWindow.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.time_series</span></code>.SlidingWindow</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.time_series.Resampler.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.time_series</span></code>.Resampler</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.time_series.Stationarizer.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.time_series</span></code>.Stationarizer</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.time_series.TakensEmbedding.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.time_series</span></code>.TakensEmbedding</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.time_series.Labeller.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.time_series</span></code>.Labeller</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.time_series.PermutationEntropy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.time_series</span></code>.PermutationEntropy</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.time_series.PearsonDissimilarity.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.time_series</span></code>.PearsonDissimilarity</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.graphs.TransitionGraph.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.graphs</span></code>.TransitionGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.graphs.KNeighborsGraph.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.graphs</span></code>.KNeighborsGraph</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.graphs.GraphGeodesicDistance.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.graphs</span></code>.GraphGeodesicDistance</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.base.TransformerResamplerMixin.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.base</span></code>.TransformerResamplerMixin</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.pipeline.Pipeline.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.pipeline</span></code>.Pipeline</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.pipeline.make_pipeline.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.pipeline</span></code>.make_pipeline</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.meta_transformers.EntropyGenerator.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.meta_transformers</span></code>.EntropyGenerator</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.meta_transformers.BettiCurveGenerator.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.meta_transformers</span></code>.BettiCurveGenerator</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.meta_transformers.LandscapeGenerator.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.meta_transformers</span></code>.LandscapeGenerator</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gtda.utils.check_diagram.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.utils</span></code>.check_diagram</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.utils.validate_params.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.utils</span></code>.validate_params</a></li>
<li class="toctree-l1"><a class="reference internal" href="gtda.utils.validate_metric_params.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.utils</span></code>.validate_metric_params</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">giotto-tda</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code>.OneDimensionalCover</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/generated/gtda.mapper.OneDimensionalCover.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="gtda-mapper-onedimensionalcover">
<h1><a class="reference internal" href="../index.html#module-gtda.mapper" title="gtda.mapper"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gtda.mapper</span></code></a>.OneDimensionalCover<a class="headerlink" href="#gtda-mapper-onedimensionalcover" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="gtda.mapper.OneDimensionalCover">
<em class="property">class </em><code class="sig-prename descclassname">gtda.mapper.</code><code class="sig-name descname">OneDimensionalCover</code><span class="sig-paren">(</span><em class="sig-param">kind='uniform'</em>, <em class="sig-param">n_intervals=10</em>, <em class="sig-param">overlap_frac=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gtda/mapper/cover.html#OneDimensionalCover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gtda.mapper.OneDimensionalCover" title="Permalink to this definition">¶</a></dt>
<dd><p>Cover of one-dimensional data coming from open overlapping intervals.</p>
<p>In <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit</span></code></a>, given a training array <cite>X</cite> representing a collection of
real numbers, a cover of the real line by open intervals
<span class="math notranslate nohighlight">\(I_k = (a_k, b_k)\)</span> (<span class="math notranslate nohighlight">\(k = 1, \ldots, n\)</span>,
<span class="math notranslate nohighlight">\(a_k &lt; a_{k+1}\)</span>, <span class="math notranslate nohighlight">\(b_k &lt; b_{k+1}\)</span>) is constructed
based on the distribution of values in <cite>X</cite>. In <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.transform" title="gtda.mapper.OneDimensionalCover.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform</span></code></a>,
the cover is applied to a new array <cite>X’</cite> to yield a cover of <cite>X’</cite>.</p>
<p>All covers constructed in <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit</span></code></a> have <span class="math notranslate nohighlight">\(a_1 = -\infty\)</span>
and <span class="math notranslate nohighlight">\(b_n = + \infty\)</span>. Two kinds of cover are currently available:
“uniform” and “balanced”. A uniform cover is such that
<span class="math notranslate nohighlight">\(b_1 - m = b_2 - a_2 = \cdots = M - a_n\)</span> where <span class="math notranslate nohighlight">\(m\)</span> and
<span class="math notranslate nohighlight">\(M\)</span> are the minimum and maximum values in <cite>X</cite> respectively. A
balanced cover is such that approximately the same number of unique
values from <cite>X</cite> is contained in each cover interval.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>kind</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">'uniform'</span></code> | <code class="docutils literal notranslate"><span class="pre">'balanced'</span></code>, optional, default: <code class="docutils literal notranslate"><span class="pre">'uniform'</span></code></span></dt><dd><p>The kind of cover to use.</p>
</dd>
<dt><strong>n_intervals</strong><span class="classifier">int, optional, default: <code class="docutils literal notranslate"><span class="pre">10</span></code></span></dt><dd><p>The number of intervals in the cover calculated in <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit</span></code></a>.</p>
</dd>
<dt><strong>overlap_frac</strong><span class="classifier">float, optional, default: <code class="docutils literal notranslate"><span class="pre">0.1</span></code></span></dt><dd><p>If the cover is uniform, this is the ratio between the length of the
intersection between consecutive intervals and the length of each
interval. If the cover is balanced, this is the analogous fractional
overlap for a uniform cover of the closed interval
<span class="math notranslate nohighlight">\((0.5, N + 0.5)\)</span> where <span class="math notranslate nohighlight">\(N\)</span> is the number of unique
values in the training array (see the Notes).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>left_limits_</strong><span class="classifier">ndarray of shape (n_intervals,)</span></dt><dd><p>Left limits of the cover intervals computed in <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit</span></code></a>. See the
Notes.</p>
</dd>
<dt><strong>right_limits_</strong><span class="classifier">ndarray of shape (n_intervals,)</span></dt><dd><p>Right limits of the cover intervals computed in <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit</span></code></a>. See the
Notes.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gtda.mapper.CubicalCover.html#gtda.mapper.CubicalCover" title="gtda.mapper.CubicalCover"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CubicalCover</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>In the case of a balanced cover, <code class="xref py py-meth docutils literal notranslate"><span class="pre">left_limits_</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">right_limits_</span></code> are computed as follows given a training array <cite>X</cite>:
first, entries in <cite>X</cite> are ranked in ascending order, starting at 1 and
with the same rank repeated in the case of equal values; then, the closed
interval <span class="math notranslate nohighlight">\((0.5, N + 0.5)\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the maximum
rank observed, is covered uniformly with parameters <cite>n_intervals</cite> and
<cite>overlap_frac</cite>, yielding intervals <span class="math notranslate nohighlight">\((\alpha_k, \beta_k)\)</span>;
the final cover is made of intervals <span class="math notranslate nohighlight">\((a_k, b_k)\)</span> where, for
<span class="math notranslate nohighlight">\(k &gt; 1\)</span> (resp. <span class="math notranslate nohighlight">\(k &lt; \)</span>), <span class="math notranslate nohighlight">\(a_k\)</span> (resp.
<span class="math notranslate nohighlight">\(b_k\)</span>) is the value of any entry in <cite>X</cite> ranked as the floor (
resp. ceiling) of <span class="math notranslate nohighlight">\(\alpha_k\)</span> (resp. <span class="math notranslate nohighlight">\(\beta_k\)</span>).</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(self, X[, y])</p></td>
<td><p>Compute all cover interval limits according to <cite>X</cite> and store them in <code class="xref py py-attr docutils literal notranslate"><span class="pre">left_limits_</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">right_limits_</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit_transform" title="gtda.mapper.OneDimensionalCover.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(self, X[, y])</p></td>
<td><p>Fit to data, then transform it.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gtda.mapper.OneDimensionalCover.get_fitted_intervals" title="gtda.mapper.OneDimensionalCover.get_fitted_intervals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fitted_intervals</span></code></a>(self)</p></td>
<td><p>Returns the open intervals computed in <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit</span></code></a>, as a list of tuples (a, b) where a &lt; b.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gtda.mapper.OneDimensionalCover.get_params" title="gtda.mapper.OneDimensionalCover.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>(self[, deep])</p></td>
<td><p>Get parameters for this estimator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#gtda.mapper.OneDimensionalCover.set_params" title="gtda.mapper.OneDimensionalCover.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(self, \*\*params)</p></td>
<td><p>Set the parameters of this estimator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#gtda.mapper.OneDimensionalCover.transform" title="gtda.mapper.OneDimensionalCover.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(self, X[, y])</p></td>
<td><p>Compute a cover of <cite>X</cite> according to the cover of the real line computed in <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit</span></code></a>, and return it as a two-dimensional boolean array.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gtda.mapper.OneDimensionalCover.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">kind='uniform'</em>, <em class="sig-param">n_intervals=10</em>, <em class="sig-param">overlap_frac=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gtda/mapper/cover.html#OneDimensionalCover.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gtda.mapper.OneDimensionalCover.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="gtda.mapper.OneDimensionalCover.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">X</em>, <em class="sig-param">y=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gtda/mapper/cover.html#OneDimensionalCover.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gtda.mapper.OneDimensionalCover.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all cover interval limits according to <cite>X</cite> and store them
in <code class="xref py py-attr docutils literal notranslate"><span class="pre">left_limits_</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">right_limits_</span></code>. Then, return the
estimator.</p>
<p>This method is here to implement the usual scikit-learn API and hence
work in pipelines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">ndarray of shape (n_samples,) or (n_samples, 1)</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>y</strong><span class="classifier">None</span></dt><dd><p>There is no need for a target in a transformer, yet the pipeline
API requires this parameter.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">object</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gtda.mapper.OneDimensionalCover.fit_transform">
<code class="sig-name descname">fit_transform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">X</em>, <em class="sig-param">y=None</em>, <em class="sig-param">**fit_params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gtda/mapper/cover.html#OneDimensionalCover.fit_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gtda.mapper.OneDimensionalCover.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">ndarray of shape (n_samples,) or (n_samples, 1)</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>y</strong><span class="classifier">None</span></dt><dd><p>There is no need for a target in a transformer, yet the pipeline
API requires this parameter.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Xt</strong><span class="classifier">ndarray of shape (n_samples, n_cover_sets)</span></dt><dd><p>Encoding of the cover of <cite>X</cite> as a boolean array. In general,
<code class="docutils literal notranslate"><span class="pre">n_cover_sets</span></code> is less than or equal to <cite>n_intervals</cite> as empty
or duplicated cover sets are removed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gtda.mapper.OneDimensionalCover.get_fitted_intervals">
<code class="sig-name descname">get_fitted_intervals</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gtda/mapper/cover.html#OneDimensionalCover.get_fitted_intervals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gtda.mapper.OneDimensionalCover.get_fitted_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the open intervals computed in <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit</span></code></a>, as a list of
tuples (a, b) where a &lt; b.</p>
</dd></dl>

<dl class="method">
<dt id="gtda.mapper.OneDimensionalCover.get_params">
<code class="sig-name descname">get_params</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#gtda.mapper.OneDimensionalCover.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>deep</strong><span class="classifier">bool, default=True</span></dt><dd><p>If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">mapping of string to any</span></dt><dd><p>Parameter names mapped to their values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gtda.mapper.OneDimensionalCover.set_params">
<code class="sig-name descname">set_params</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">**params</em><span class="sig-paren">)</span><a class="headerlink" href="#gtda.mapper.OneDimensionalCover.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>**params</strong><span class="classifier">dict</span></dt><dd><p>Estimator parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">object</span></dt><dd><p>Estimator instance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gtda.mapper.OneDimensionalCover.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">X</em>, <em class="sig-param">y=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/gtda/mapper/cover.html#OneDimensionalCover.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gtda.mapper.OneDimensionalCover.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a cover of <cite>X</cite> according to the cover of the real line
computed in <a class="reference internal" href="#gtda.mapper.OneDimensionalCover.fit" title="gtda.mapper.OneDimensionalCover.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit</span></code></a>, and return it as a two-dimensional boolean
array. Each column indicates the location of entries in <cite>X</cite>
belonging to a common cover interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">ndarray of shape (n_samples,) or (n_samples, 1)</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>y</strong><span class="classifier">None</span></dt><dd><p>There is no need for a target in a transformer, yet the pipeline
API requires this parameter.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Xt</strong><span class="classifier">ndarray of shape (n_samples, n_cover_sets)</span></dt><dd><p>Encoding of the cover of <cite>X</cite> as a boolean array. In general,
<code class="docutils literal notranslate"><span class="pre">n_cover_sets</span></code> is less than or equal to <cite>n_intervals</cite> as empty
or duplicated cover sets are removed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="clearer"></div></div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gtda.mapper.CubicalCover.html" class="btn btn-neutral float-right" title="gtda.mapper.CubicalCover" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="gtda.mapper.Entropy.html" class="btn btn-neutral float-left" title="gtda.mapper.Entropy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, L2F

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>